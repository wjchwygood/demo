!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports,require("@angular/core"),require("rxjs/add/observable/fromEvent"),require("rxjs/add/observable/of"),require("rxjs/add/operator/filter"),require("rxjs/add/operator/mergeMap"),require("rxjs/add/operator/sampleTime"),require("rxjs/Observable")):"function"==typeof define&&define.amd?define(["exports","@angular/core","rxjs/add/observable/fromEvent","rxjs/add/observable/of","rxjs/add/operator/filter","rxjs/add/operator/mergeMap","rxjs/add/operator/sampleTime","rxjs/Observable"],factory):factory((global.ng=global.ng||{},global.ng.ngxInfiniteScroll=global.ng.ngxInfiniteScroll||{}),global.ng.core,null,null,null,null,null,global.Rx)}(this,function(exports,_angular_core,rxjs_add_observable_fromEvent,rxjs_add_observable_of,rxjs_add_operator_filter,rxjs_add_operator_mergeMap,rxjs_add_operator_sampleTime,rxjs_Observable){"use strict";function resolveContainerElement(selector,scrollWindow,defaultElement,fromRoot){var hasWindow=window&&!!window.document,containerIsString=selector&&hasWindow&&"string"==typeof selector,container=hasWindow&&scrollWindow?window:defaultElement;return containerIsString&&(container=containerIsString?findElement(selector,defaultElement.nativeElement,fromRoot):selector),container}function findElement(selector,customRoot,fromRoot){return(fromRoot?window.document:customRoot).querySelector(selector)}function inputPropChanged(prop){return prop&&!prop.firstChange}function hasWindowDefined(){return"undefined"!=typeof window}function shouldTriggerEvents(_a){var alwaysCallback=_a.alwaysCallback,shouldScroll=_a.shouldScroll,disable=_a.disable;return(alwaysCallback||shouldScroll)&&!disable}function triggerEvents(callbacks,isScrollingDown,scrolledUntilNow){var eventData={currentScrollPosition:scrolledUntilNow};(isScrollingDown?callbacks.down:callbacks.up)(eventData)}function createResolver(_a){var isWindow=_a.isWindow,windowElement=_a.windowElement;return createResolverWithContainer({axis:_a.axis,isWindow:isWindow},windowElement)}function createResolverWithContainer(resolver,windowElement){var container=resolver.isWindow||windowElement&&!windowElement.nativeElement?windowElement:windowElement.nativeElement;return Object.assign({},resolver,{container:container})}function isElementWindow(windowElement){return["Window","global"].some(function(obj){return Object.prototype.toString.call(windowElement).includes(obj)})}function getDocumentElement(isContainerWindow,windowElement){return isContainerWindow?windowElement.document.documentElement:null}function calculatePoints(element,resolver){var height=extractHeightForElement(resolver);return resolver.isWindow?calculatePointsForWindow(height,element,resolver):calculatePointsForElement(height,element,resolver)}function calculatePointsForWindow(height,element,resolver){var axis=resolver.axis,container=resolver.container,isWindow=resolver.isWindow,_a=extractHeightPropKeys(axis),offsetHeightKey=_a.offsetHeightKey,clientHeightKey=_a.clientHeightKey,scrolledUntilNow=height+getElementPageYOffset(getDocumentElement(isWindow,container),axis,isWindow),nativeElementHeight=getElementHeight(element.nativeElement,isWindow,offsetHeightKey,clientHeightKey);return{height:height,scrolledUntilNow:scrolledUntilNow,totalToScroll:getElementOffsetTop(element.nativeElement,axis,isWindow)+nativeElementHeight}}function calculatePointsForElement(height,element,resolver){var axis=resolver.axis,container=resolver.container;return{height:height,scrolledUntilNow:container[axis.scrollTopKey()],totalToScroll:container[axis.scrollHeightKey()]}}function extractHeightPropKeys(axis){return{offsetHeightKey:axis.offsetHeightKey(),clientHeightKey:axis.clientHeightKey()}}function extractHeightForElement(_a){var container=_a.container,isWindow=_a.isWindow,axis=_a.axis,_b=extractHeightPropKeys(axis);return getElementHeight(container,isWindow,_b.offsetHeightKey,_b.clientHeightKey)}function getElementHeight(elem,isWindow,offsetHeightKey,clientHeightKey){return isNaN(elem[offsetHeightKey])?getDocumentElement(isWindow,elem)[clientHeightKey]:elem[offsetHeightKey]}function getElementOffsetTop(elem,axis,isWindow){var topKey=axis.topKey();if(elem.getBoundingClientRect)return elem.getBoundingClientRect()[topKey]+getElementPageYOffset(elem,axis,isWindow)}function getElementPageYOffset(elem,axis,isWindow){var pageYOffset=axis.pageYOffsetKey(),scrollTop=axis.scrollTopKey(),offsetTop=axis.offsetTopKey();return isNaN(window[pageYOffset])?getDocumentElement(isWindow,elem)[scrollTop]:elem.ownerDocument?elem.ownerDocument.defaultView[pageYOffset]:elem[offsetTop]}function shouldScroll(container,config,scrollingDown){var remaining,containerBreakpoint,distance=config.distance;return scrollingDown?(remaining=container.totalToScroll-container.scrolledUntilNow,containerBreakpoint=container.height*distance.down+1):(remaining=container.scrolledUntilNow,containerBreakpoint=container.height*distance.up+1),remaining<=containerBreakpoint}function isScrollingDownwards(lastScrollPosition,container){return lastScrollPosition<container.scrolledUntilNow}function getScrollStats(lastScrollPosition,container,config){var isScrollingDown=isScrollingDownwards(lastScrollPosition,container);return{shouldScroll:shouldScroll(container,config,isScrollingDown),isScrollingDown:isScrollingDown}}function updateScrollPosition(position,lastPositionState){return lastPositionState.last=position}function attachScrollEvent(options){return rxjs_Observable.Observable.fromEvent(options.container,"scroll").sampleTime(options.throttleDuration).mergeMap(function(ev){return rxjs_Observable.Observable.of(options.mergeMap(ev))}).subscribe(options.scrollHandler)}function createScroller(config){var containerElement=resolveContainerElement(config.scrollContainer,config.scrollWindow,config.element,config.fromRoot),resolver=createResolver({axis:new AxisResolver(!config.horizontal),isWindow:isElementWindow(containerElement),windowElement:containerElement}),scrollPosition={last:0};return attachScrollEvent({container:resolver.container,mergeMap:function(){return calculatePoints(config.element,resolver)},scrollHandler:function(positionStats){return handleOnScroll(scrollPosition,positionStats,config)},throttleDuration:config.throttle})}function handleOnScroll(scrollPosition,positionStats,config){var distance={down:config.downDistance,up:config.upDistance},_a=getScrollStats(scrollPosition.last,positionStats,{distance:distance}),isScrollingDown=_a.isScrollingDown,shouldScroll$$1=_a.shouldScroll,scrollConfig={alwaysCallback:config.alwaysCallback,disable:config.disable,shouldScroll:shouldScroll$$1};updateScrollPosition(positionStats.scrolledUntilNow,scrollPosition),shouldTriggerEvents(scrollConfig)&&triggerEvents(config.events,isScrollingDown,positionStats.scrolledUntilNow)}var AxisResolver=function(){function AxisResolver(vertical){void 0===vertical&&(vertical=!0),this.vertical=vertical}return AxisResolver.prototype.clientHeightKey=function(){return this.vertical?"clientHeight":"clientWidth"},AxisResolver.prototype.offsetHeightKey=function(){return this.vertical?"offsetHeight":"offsetWidth"},AxisResolver.prototype.scrollHeightKey=function(){return this.vertical?"scrollHeight":"scrollWidth"},AxisResolver.prototype.pageYOffsetKey=function(){return this.vertical?"pageYOffset":"pageXOffset"},AxisResolver.prototype.offsetTopKey=function(){return this.vertical?"offsetTop":"offsetLeft"},AxisResolver.prototype.scrollTopKey=function(){return this.vertical?"scrollTop":"scrollLeft"},AxisResolver.prototype.topKey=function(){return this.vertical?"top":"left"},AxisResolver}(),InfiniteScrollDirective=function(){function InfiniteScrollDirective(element,zone){this.element=element,this.zone=zone,this.scrolled=new _angular_core.EventEmitter,this.scrolledUp=new _angular_core.EventEmitter,this.infiniteScrollDistance=2,this.infiniteScrollUpDistance=1.5,this.infiniteScrollThrottle=300,this.infiniteScrollDisabled=!1,this.infiniteScrollContainer=null,this.scrollWindow=!0,this.immediateCheck=!1,this.horizontal=!1,this.alwaysCallback=!1,this.fromRoot=!1}return InfiniteScrollDirective.prototype.ngAfterViewInit=function(){this.infiniteScrollDisabled||this.setup()},InfiniteScrollDirective.prototype.ngOnChanges=function(_a){var infiniteScrollContainer=_a.infiniteScrollContainer,infiniteScrollDisabled=_a.infiniteScrollDisabled,infiniteScrollDistance=_a.infiniteScrollDistance,containerChanged=inputPropChanged(infiniteScrollContainer),disabledChanged=inputPropChanged(infiniteScrollDisabled),distanceChanged=inputPropChanged(infiniteScrollDistance),shouldSetup=!disabledChanged&&!this.infiniteScrollDisabled||disabledChanged&&!infiniteScrollDisabled.currentValue||distanceChanged;(containerChanged||disabledChanged||distanceChanged)&&(this.destroyScroller(),shouldSetup&&this.setup())},InfiniteScrollDirective.prototype.setup=function(){var _this=this;hasWindowDefined()&&this.zone.runOutsideAngular(function(){_this.disposeScroller=createScroller({fromRoot:_this.fromRoot,alwaysCallback:_this.alwaysCallback,disable:_this.infiniteScrollDisabled,downDistance:_this.infiniteScrollDistance,element:_this.element,events:{down:function(event){return _this.zone.run(function(){return _this.scrolled.emit(event)})},up:function(event){return _this.zone.run(function(){return _this.scrolledUp.emit(event)})}},horizontal:_this.horizontal,scrollContainer:_this.infiniteScrollContainer,scrollWindow:_this.scrollWindow,throttle:_this.infiniteScrollThrottle,upDistance:_this.infiniteScrollUpDistance})})},InfiniteScrollDirective.prototype.ngOnDestroy=function(){this.destroyScroller()},InfiniteScrollDirective.prototype.destroyScroller=function(){this.disposeScroller&&this.disposeScroller.unsubscribe()},InfiniteScrollDirective}();InfiniteScrollDirective.decorators=[{type:_angular_core.Directive,args:[{selector:"[infiniteScroll], [infinite-scroll], [data-infinite-scroll]"}]}],InfiniteScrollDirective.ctorParameters=function(){return[{type:_angular_core.ElementRef},{type:_angular_core.NgZone}]},InfiniteScrollDirective.propDecorators={scrolled:[{type:_angular_core.Output}],scrolledUp:[{type:_angular_core.Output}],infiniteScrollDistance:[{type:_angular_core.Input}],infiniteScrollUpDistance:[{type:_angular_core.Input}],infiniteScrollThrottle:[{type:_angular_core.Input}],infiniteScrollDisabled:[{type:_angular_core.Input}],infiniteScrollContainer:[{type:_angular_core.Input}],scrollWindow:[{type:_angular_core.Input}],immediateCheck:[{type:_angular_core.Input}],horizontal:[{type:_angular_core.Input}],alwaysCallback:[{type:_angular_core.Input}],fromRoot:[{type:_angular_core.Input}]};var InfiniteScrollModule=function(){function InfiniteScrollModule(){}return InfiniteScrollModule}();InfiniteScrollModule.decorators=[{type:_angular_core.NgModule,args:[{declarations:[InfiniteScrollDirective],exports:[InfiniteScrollDirective],imports:[],providers:[]}]}],InfiniteScrollModule.ctorParameters=function(){return[]},exports.InfiniteScrollDirective=InfiniteScrollDirective,exports.InfiniteScrollModule=InfiniteScrollModule,Object.defineProperty(exports,"__esModule",{value:!0})});
//# sourceMappingURL=ngx-infinite-scroll.umd.min.js.map
